package blst

import (
	"fmt"
	bls "github.com/clearmatics/autonity/crypto/bls/common"
	"testing"
	"time"
)

/*
  Hybrid Aggregation:
  The idea of hybrid aggregation is to vertically aggregate multiple different signatures of the same voting messages into
  single signature, then to horizontally aggregate the signatures generated by vertical aggregation into single signature
  for the entire epoch, such that we gain with less storage cost.
*/

type EpochActivityProofHybrid struct {
	MinRoundsPerHeight  []int // min round number of each height from 1st height to the last height of the Epoch.
	AggregatedSignature bls.BLSSignature
	Absences            []AbsentParticipants //to recreate the msgs and to recreate the aggregated public keys.
}

// generate a full view of the entire proof of activities, let's assume there are no omission.
func GenerateEpochActivityProofHybrid(v []bls.BLSSecretKey, epochLength int, avgRound int) EpochActivityProofHybrid {
	endHeight := uint64(epochLength)
	eProof := EpochActivityProofHybrid{}
	verticalAggSignatures := make([]bls.BLSSignature, 0, epochLength*avgRound*2)
	for h := uint64(0); h < endHeight; h++ {
		eProof.MinRoundsPerHeight = append(eProof.MinRoundsPerHeight, avgRound)
		for r := uint64(0); r < uint64(avgRound); r++ {
			for s := uint8(0); s < uint8(2); s++ {
				m := Msg{
					H: h,
					R: r,
					S: s,
				}
				sigs := make([]bls.BLSSignature, 0, len(v))
				for i := 0; i < len(v); i++ {
					sig := v[i].Sign(m.hash().Bytes())
					sigs = append(sigs, sig)
				}
				aggSig := AggregateSignatures(sigs)
				verticalAggSignatures = append(verticalAggSignatures, aggSig)
			}
		}
	}
	eProof.AggregatedSignature = AggregateSignatures(verticalAggSignatures)
	return eProof
}

// we assume there are no omission faults, let's experience the performance over signature verification
func ValidateEpochActivityProofHybrid(p EpochActivityProofHybrid, startHeight uint64, pubKeys []bls.BLSPublicKey) (time.Duration, bool) {
	beforeTest := time.Now()
	epochLength := len(p.MinRoundsPerHeight)
	endHeight := startHeight + uint64(epochLength)
	// assume there are no omission faults, so we recreate all the msgs and aggregated public keys.
	aggPublicKeys := make([]bls.BLSPublicKey, 0, epochLength*2*2)
	msgs := make([][32]byte, 0, epochLength*2*2)
	for h := startHeight; h < endHeight; h++ {
		minRound := p.MinRoundsPerHeight[h-startHeight]
		for r := uint64(0); r < uint64(minRound); r++ {
			for s := uint8(0); s < uint8(2); s++ {
				m := Msg{
					H: h,
					R: r,
					S: s,
				}
				aggPublicKeys = append(aggPublicKeys, AggregatePublicKeysV2(pubKeys))
				msgs = append(msgs, m.hash())
			}
		}
	}
	ok := p.AggregatedSignature.AggregateVerify(aggPublicKeys, msgs)
	if !ok {
		panic(ok)
	}
	afterTest := time.Now()
	return afterTest.Sub(beforeTest), true
}

func runHybridAggTest(committeeSize int, epochLength int, avgRound int) time.Duration {
	secretKeys, pubKeys, err := GenerateValidators(committeeSize)
	if err != nil {
		panic(err)
	}

	// now we generate the epoch proof for a single validator, and verify it. In production case, there would be multiple
	// ones for verification since all the validator will submit a proof for an epoch.

	// generate the entire proof of activity of the epoch from Pi.
	eProof := GenerateEpochActivityProofHybrid(secretKeys, epochLength, avgRound)
	// validate the proof sent by pi.

	duration, ok := ValidateEpochActivityProofHybrid(eProof, uint64(0), pubKeys)
	if !ok {
		panic(ok)
	}
	return duration
}

func TestHybridAggWithDifferentSettings(t *testing.T) {
	tests := []struct{
		name          string
		committeeSize int
		lengthOfEPoch int
		averageRound  int
	}{
		{
			"hybrid aggregation: \t 10 validators, 30 blocks epoch, average min round 2",
			10,
			30,
			2,
		},
		{
			"hybrid aggregation: \t 10 validators, 60 blocks epoch, average min round 2",
			10,
			60,
			2,
		},
		{
			"hybrid aggregation: \t 10 validators, 90 blocks epoch, average min round 2",
			10,
			90,
			2,
		},
		{
			"hybrid aggregation: \t 15 validators, 30 blocks epoch, average min round 2",
			15,
			30,
			2,
		},
		{
			"hybrid aggregation: \t 15 validators, 60 blocks epoch, average min round 2",
			15,
			60,
			2,
		},
		{
			"hybrid aggregation: \t 15 validators, 90 blocks epoch, average min round 2",
			15,
			90,
			2,
		},
		{
			"hybrid aggregation: \t 21 validators, 30 blocks epoch, average min round 2",
			21,
			30,
			2,
		},
		{
			"hybrid aggregation: \t 21 validators, 60 blocks epoch, average min round 2",
			21,
			60,
			2,
		},
		{
			"hybrid aggregation: \t 21 validators, 90 blocks epoch, average min round 2",
			21,
			90,
			2,
		},
	}

	times := 10
	fmt.Println()
	for _, test := range tests {
		fmt.Println(test.name)
		d := time.Duration(0)
		for i:=0; i<times; i++ {
			d += runHybridAggTest(test.committeeSize, test.lengthOfEPoch, test.averageRound)
		}
		fmt.Println("AVG time: \t", d.Seconds()/float64(times), "seconds to verify", test.committeeSize, "sets of aggregated messages with each set of", test.lengthOfEPoch*test.averageRound*2, "messages")
		fmt.Println()
	}
}
